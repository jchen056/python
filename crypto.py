# -*- coding: utf-8 -*-
"""crypto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sgutlDiZLj5CY8c98kyAlmJh9QtlkI1N

Alice wants to send a secret number to Bob over an open channel. She does that by sending a sequence of N bits, so that the sum of bits (equivalently, the number of "1" bits) is her secret number, call it S.

For whatever reason, each bit is transmitted correctly with a fixed probability p<1. That is, with probability (1-p), any bit b transmitted by Alice is received as (1-b) by Bob.

If Bob knows p and N, he can compute the expected value of S, and thereby estimate S. Our goal will be to figure out how accurate this estimation of S is.

Assume p(bi=1)=a and p(bi=0)=1-a

E(S)=E(b1)+E(b2)+E(b3)+...+E(bN)

=p(b1=1)*1+p(b1=0)*0+p(b2=1)*1+p(b2=0)*0+...+p(bN=1)*1+p(bN=0)*0

=N*(a*1+(1-a)*0)=N*a


E(S’)=E(b'1)+E(b'2)+E(b'3)+...+E(b'N)=p(b'1=b1)*b1+p(b'1=1-b1)*(1-b1)+p(b'2=b2)*b2+p(b'2=1-b2)*(1-b2)+...+p(b'N=bN)*bN+p(b'N=1-bN)*(1-bN)

=p*b1+(1-p)*(1-b1)+p*b2+(1-p)*(1-b2)+...+p*bN+(1-p)(1-bN)

=p*(b1+b2+...+bN)+(1-p)*(1-b1+1-b2+...+1-bN)

By definition, S=b1+b2+...+bN

E(S’)=p*S+(1-p)*(N*1-(b1+b2+...+bN))

=p*S+(1-p)*(N-S)

=p*S+N-S-p*N+p*S

=2pS+N-S-p*N
"""

# importing "random" for random operations
import random
import numpy as np
#a is the probability of getting 1; p(b=1)=a and p(b=0)=1-a
#throw the coin N times
def coin_toss(N,a):
  y=[None]*N
  for i in range(1,(N+1)):
    b=random.random()#produce a random number btw 0 and 1
    if b<(1-a):
      y[i-1]=0
    else:
      y[i-1]=1
  return y

N=int(input("please enter an integer for N:"))
print("N=",N)
a=float(input("please enter a decimal between 0 and 1 for the p(bi=1):"))
print("p(bi=1)=",a)

#n is the number of trials; how many times Bob is sending Alice msgs
# def s_trials(n,N,a):
#   y=[None]*n
#   for i in range(1,(n+1)):
#     s=sum(coin_toss(N,a))
#     y[i-1]=s
#   m=sum(y)/len(y)
#   return m

"""what happens when there is mutation?"""

#p(b'=b)=p and p(b'=1-b)=1-p
def mut(p,b):
  x=random.random()
  if x<1-p:#the bit does not change
    return 1-b
  else:#the bit flips
    return b

# print(mut(1,0))
def s_mutation(S,p):
  y=S[:]
  N=len(S)
  for i in range(1,(1+N)):
    x=mut(p,y[i-1])
    y[i-1]=x
  return y

S=coin_toss(N,a)
print("S=",sum(S))
print()
p=float(input("enter a number for p(mutation rate,p!=0.5):"))
print("p=",p)
S_p=s_mutation(S,p)
sp=sum(S_p)
# print("S_p=",sp)

def est_S(sp,N,p):
  return (sp-N*(1-p))/(2*p-1)

#S before mutation estimated by Bob
S_b=est_S(sp,N,p)
print("S estimated by Bob=",S_b)
# def trials(n,S,p):
#   y=[None]*n
#   for i in range(1,(n+1)):
#     s_p=s_mutation(S,p)
#     y[i-1]=sum(s_p)
#   m=sum(y)/len(y)
#   return m