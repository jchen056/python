# -*- coding: utf-8 -*-
"""numpy1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ItVD_tpU5L4-n9gg9CRqEAM7E3T3wKo6

NumPy is built around ndarrays objects
"""

import numpy as np
lst=[[1,2,3],[4,5,6]]
arylst=np.array(lst)
arylst

#accessing the dtype attribute
arylst.dtype

#return the number of elements in an array
arylst.size

#the number of dimensions of an array (intuitively, you may think of dimensions as the rank of a tensor)
arylst.ndim

#you want not only dimension but also the number of elements
arylst.shape

#construct a zero-dimensional array 
#(for instance, a representation of a scalar)
scalar=np.array(5)
scalar
scalar.ndim
scalar.shape

"""let us create ndarrays of con-
sisting of either ones and zeros by only specifying the elements along each
axes
"""

np.ones(5)
np.ones((2,3))
np.zeros((3,3,3))

#if we do not need the initial values
np.empty((2,2))

#cretae identity matrix n by n
np.eye(2)
np.diag((1,1,1))

"""two very useful functions for creating se-
quences of numbers within a specified range, namely, **arange and linspace**.

NumPy’s arange function follows the same syntax as Python’s range ob-
jects:
"""

np.arange(4., 10.)
np.linspace(0., 1., num=3)

#modfications on slicing array will be reflected on the original array
ary=np.array([[1,2,3],[4,5,6]])
ary[0,0]#upper left
ary[-1,-1]#lower right
subarr=ary[:,0]#first column
subarr[0]=5
ary

"""It is about time to cover one of the
core features of NumPy that makes working with ndarray so efficient and
convenient: **vectorization**.NumPy provides
vectorized wrappers for performing element-wise operations implicitly via
so-called ufuncs – short for universal functions.
"""

ary = np.array([[1, 2, 3], [4, 5, 6]])
ary = np.add(ary, 1)
ary=ary + 1
ary=ary**2#exponential: square
ary

#tranpose
ary.T

"""NumPy supports advanced indexing routines called **fancy indexing**. Via fancy indexing, we can *use tuple or list objects of non-contiguous integer indices* to return desired array elements. Since fancy indexing can be performed
with non-contiguous sequences, it cannot return a view – a contiguous slice
from memory. Thus, *fancy indexing always returns a copy of an array* – it
is important to keep that in mind.
"""

this_is_a_copy=ary[:,[0,2]]#the first and third col
this_is_a_copy+=1
ary#notice ary does not change

"""use Boolean masks for indexing – that is, arrays of
True and False values. Consider the following example, where we return
all values in the array that are greater than 3:
"""

ary=np.array([[1,2,3],[4,5,6]])
greater3_mask=ary>3
greater3_mask
ary[greater3_mask]#mask indexing
ary[(ary > 3) & (ary % 2 == 0)]

"""***np.where*** function with three arguments:
np.where(condition, x, y),
which is interpreted as
If condition is True, yield x, otherwise yield y.
"""

np.where(ary>2,1,0)