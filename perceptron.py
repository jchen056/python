# -*- coding: utf-8 -*-
"""perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XU8sCnDBaJD808JtbEMm21zFRQqUptWr

**Matplotlib** graphs your data on Figures (e.g., windows, Jupyter widgets, etc.), each of which can contain one or more Axes, an area where points can be specified in terms of x-y coordinates (or theta-r in a polar plot, x-y-z in a 3D plot, etc).
"""

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np

class Perceptron(object):
    """Perceptron classifier.
    Parameters
    ------------
    eta : float; learning rate (between 0.0 and 1.0)
    n_iter : int; Passes over the training dataset.
    random_state : int; Random number generator seed for random weight initialization.
    
    Attributes
    -----------
    w_ : 1d-array; Weights after fitting.
    errors_ : list; Number of misclassifications (updates) in each epoch.
    """
    
    def __init__(self, eta=0.01, n_iter=50, random_state=1):
        self.eta = eta
        self.n_iter = n_iter
        self.random_state = random_state

    def fit(self, X, y):
        """Fit training data.
        Parameters
        ----------
        X : {array-like}, shape = [n_examples, n_features]
          Training vectors, where n_examples is the number of examples and
          n_features is the number of features.
        y : array-like, shape = [n_examples]
          Target values.
        Returns
        -------
        self : object
        """
        rgen = np.random.RandomState(self.random_state)#Random number generator seed for random weight initialization.
        self.w_ = rgen.normal(loc=0.0, scale=0.01, size=1 + X.shape[1])#weights=1+number of dimensions
  #important to note that we do not initialize the weights to be zero
  #bc the learning rate only has an effect on the classfication outcome if weights are initialized to non-zero numbers
        self.errors_ = []#the number of misclassfications during each epoch

        for _ in range(self.n_iter):
            errors = 0
            for xi, target in zip(X, y):
                update = self.eta * (target - self.predict(xi))
                self.w_[1:] += update * xi
                self.w_[0] += update
                errors += int(update != 0.0)
            self.errors_.append(errors)
        return self

    def net_input(self, X):
        """Calculate net input"""
        return np.dot(X, self.w_[1:]) + self.w_[0]

    def predict(self, X):
        """Return class label after unit step"""
        return np.where(self.net_input(X) >= 0.0, 1, -1)

"""pandas: https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html"""

import os
import pandas as pd

labels=['a','b','c']
my_data=[10,20,30]
#Creating a Series by passing a list of values, letting pandas create a default integer index:
s=pd.Series(data=my_data,index=labels)
s = pd.Series([1, 3, 5, np.nan, 6, 8])
s

#dataframe
dates = pd.date_range("20130101", periods=6)
dates
df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list("ABCD"))#random.randn gives Random values in a given shape.
df=pd.DataFrame(np.random.randn(5,5),index=list("ABCDE"),columns=list("12345"))
df
df['sum']=df['1']+df['2']
df

df2 = pd.DataFrame(
    {
        "A": 1.0,
        "B": pd.Timestamp("20130102"),
        "C": pd.Series(1, index=list(range(4)), dtype="float32"),
        "D": np.array([3] * 4, dtype="int32"),
        "E": pd.Categorical(["test", "train", "test", "train"]),
        "F": "foo",
    }
)
df2
df2.dtypes

"""Here is how to view the top and bottom rows of the frame:"""

df.head()
df.tail(3)
df.index
df.columns
#NumPy arrays have one dtype for the entire array, while pandas DataFrames have one dtype per column
#DataFrame.to_numpy() gives a NumPy representation of the underlying data: can be very exp
df.to_numpy()
#describe() shows a quick statistic summary of your data:
df.describe()
df.T#Transposing your data:

df = pd.read_csv('https://archive.ics.uci.edu/ml/'
        'machine-learning-databases/iris/iris.data', header=None)
df.tail()
df.head()

# select setosa and versicolor
y = df.iloc[0:100, 4].values
y = np.where(y == 'Iris-setosa', -1, 1)
print(y)
# extract sepal length and petal length
X = df.iloc[0:100, [0, 2]].values

plt.scatter(X[:50, 0], X[:50, 1],
            color='red', marker='o', label='setosa')
plt.scatter(X[50:100, 0], X[50:100, 1],
            color='blue', marker='x', label='versicolor')
plt.xlabel('sepal length [cm]')
plt.ylabel('petal length [cm]')
plt.legend(loc='upper left')
# plt.savefig('images/02_06.png', dpi=300)
plt.show()


# ### Training the perceptron model



ppn = Perceptron(eta=0.1, n_iter=10)
ppn.fit(X, y)
plt.plot(range(1, len(ppn.errors_) + 1), ppn.errors_, marker='o')
plt.xlabel('Epochs')
plt.ylabel('Number of updates')

# plt.savefig('images/02_07.png', dpi=300)
plt.show()

from matplotlib.colors import ListedColormap
def plot_decision_regions(X, y, classifier, resolution=0.02):

    # setup marker generator and color map
    markers = ('s', 'x', 'o', '^', 'v')
    colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan')
    cmap = ListedColormap(colors[:len(np.unique(y))])

    # plot the decision surface
    x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),
                           np.arange(x2_min, x2_max, resolution))
    Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T)
    Z = Z.reshape(xx1.shape)
    plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap)
    plt.xlim(xx1.min(), xx1.max())
    plt.ylim(xx2.min(), xx2.max())

    # plot class samples
    for idx, cl in enumerate(np.unique(y)):
        plt.scatter(x=X[y == cl, 0], 
                    y=X[y == cl, 1],
                    alpha=0.8, 
                    c=colors[idx],
                    marker=markers[idx], 
                    label=cl, 
                    edgecolor='black')




plot_decision_regions(X, y, classifier=ppn)
plt.xlabel('sepal length [cm]')
plt.ylabel('petal length [cm]')
plt.legend(loc='upper left')


# plt.savefig('images/02_08.png', dpi=300)
plt.show()

from sklearn import datasets
import numpy as np

iris = datasets.load_iris()
X = iris.data[:, [2, 3]]
y = iris.target
print('Class labels:', np.unique(y))#return unique class labels stored in y

#Splitting data into 70% training and 30% test data:
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=1, stratify=y)#using a fixed random_state ensures that our results are reproducible
    #stratify means that returns training and test subsets havve the same proportions of class labels as the input dataset
print('Labels count in y:', np.bincount(y))
print('Labels count in y_train:', np.bincount(y_train))
print('Labels count in y_test:', np.bincount(y_test))

"""Standardizing the features:

ml and optimization algorithms require feature scaling for optimal performance
"""

from sklearn.preprocessing import StandardScaler#load StandardScaler class from the preprocessing module

sc = StandardScaler()
sc.fit(X_train)#estimate mean and stadnard deviation for each feature dimension from the trainingd data
X_train_std = sc.transform(X_train)#standardize using estimated mean and standard deviation
X_test_std = sc.transform(X_test)

from sklearn.linear_model import Perceptron

ppn = Perceptron(eta0=0.1, random_state=1)
ppn.fit(X_train_std, y_train)#fitting using training data

y_pred = ppn.predict(X_test_std)#prediction using testingd data
print('Misclassified examples: %d' % (y_test != y_pred).sum())

# a variety of performance metrics 
from sklearn.metrics import accuracy_score

print('Accuracy: %.3f' % accuracy_score(y_test, y_pred))