# -*- coding: utf-8 -*-
"""bfs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18PsztVa4AQzzqDLRNSzlvWE_Te8L5G9o
"""

# #copy from https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/
# #only works for integer, not recommended
# # print BFS traversal from a given source vertex. BFS(int s)
# # traverses vertices reachable from s.
# from collections import defaultdict
# #defualtdict never raises a KeyError. It provides a default value for the key that does not exists

# # This class represents a directed graph using adjacency list representation
# class Graph:
#     # Constructor
#     def __init__(self):
 
#         # default dictionary to store graph
#         self.graph = defaultdict(list)
 
#     # function to add an edge to graph
#     def addEdge(self,u,v):
#         self.graph[u].append(v)
 
#     # Function to print a BFS of graph
#     def BFS(self, s):
 
#         # Mark all the vertices as not visited
#         visited = [False] * (max(self.graph) + 1)
 
#         # Create a queue for BFS
#         queue = []
 
#         # Mark the source node as
#         # visited and enqueue it
#         queue.append(s)
#         visited[s] = True
 
#         while queue:
 
#             # Dequeue a vertex from
#             # queue and print it
#             s = queue.pop(0)
#             print (s, end = " ")
 
#             # Get all adjacent vertices of the dequeued vertex s. 
#             # If a adjacent has not been visited, then mark it
#             # visited and enqueue it
#             for i in self.graph[s]:
#                 if visited[i] == False:
#                     queue.append(i)
#                     visited[i] = True
 
# # Driver code
 
# # Create a graph given in
# # the above diagram
# g = Graph()
# g = Graph()
# g.addEdge(0, 1)
# g.addEdge(0, 2)
# g.addEdge(1, 2)
# g.addEdge(2, 0)
# g.addEdge(2, 3)
# g.addEdge(3, 3)

# print ("Following is Breadth First Traversal"
#                   " (starting from vertex 2)")
# g.BFS(2)

#step1: build a adjacency list to represent the graph
graph = {
  'v' : ['r'],
  'r' : ['v', 's'],
  's' : ['r','w'],
  'w' : ['s','t','x'],
  'x' : ['w','t','y'],
  't' : ['w','x','u'],
  'u': ['t','y'],
  'y': ['x','u']

}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)
  #print(queue)
  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
    #print(queue)
# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, 's')    # function calling